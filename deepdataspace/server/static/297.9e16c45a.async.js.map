{"version":3,"file":"297.9e16c45a.async.js","mappings":";AA+TA","sources":["webpack://app/./src/hooks/useCanvasContainer.tsx"],"sourcesContent":["import React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { useEventListener, useMouse, useSize } from 'ahooks';\nimport { useImmer } from 'use-immer';\nimport { isInCanvas } from '@/utils/compute';\nimport { zoomImgSize } from '@/utils/annotation';\nimport {\n  MIN_SCALE,\n  MAX_SCALE,\n  BUTTON_SCALE_STEP,\n  WHEEL_SCALE_STEP,\n} from '@/constants';\nimport { fixedFloatNum } from '@/utils/digit';\n\ninterface IProps {\n  isRequiring: boolean;\n  visible: boolean;\n  minPadding?: {\n    top: number;\n    left: number;\n  };\n  allowMove: boolean;\n  isCustomCursorActive: boolean;\n  cursorSize: number;\n  showReferenceLine?: boolean;\n  onClickBg?: React.MouseEventHandler<HTMLDivElement>;\n}\n\nexport default function useCanvasContainer({\n  isRequiring,\n  visible,\n  minPadding = { top: 0, left: 0 },\n  allowMove,\n  showReferenceLine,\n  isCustomCursorActive,\n  cursorSize,\n  onClickBg,\n}: IProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const containerSize = useSize(() => containerRef.current);\n  const containerMouse = useMouse(() => containerRef.current); // delayed get size when move don't move\n\n  /** The original size of image */\n  const [naturalSize, setNaturalSize] = useState<ISize>({\n    width: 0,\n    height: 0,\n  });\n\n  /** The scaled size of image */\n  const [clientSize, setClientSize] = useImmer<{\n    width: number;\n    height: number;\n    scale: number;\n  }>({\n    width: naturalSize.width,\n    height: naturalSize.height,\n    scale: 1,\n  });\n\n  /** The top-left location on canvas container */\n  const imagePos = useRef<IPoint>({ x: 0, y: 0 });\n\n  // Scale info\n  const lastScalePosRef = useRef<\n    | {\n        posRatioX: number;\n        posRatioY: number;\n        mouseX: number;\n        mouseY: number;\n      }\n    | undefined\n  >(undefined);\n\n  const contentMouse = useMemo(() => {\n    return {\n      ...containerMouse,\n      elementW: clientSize.width,\n      elementH: clientSize.height,\n      elementX: containerMouse.elementX - imagePos.current.x,\n      elementY: containerMouse.elementY - imagePos.current.y,\n    };\n  }, [containerMouse, clientSize]);\n\n  const [movingImgAnchor, setMovingImgAnchor] = useImmer<IPoint | null>(null);\n\n  const initClientSizeToFit = (naturalSize: ISize) => {\n    if (naturalSize && containerSize) {\n      const containerWidth = containerSize.width;\n      const containerHeight = containerSize.height;\n      const [width, height, scale] = zoomImgSize(\n        naturalSize.width,\n        naturalSize.height,\n        containerWidth - minPadding.left * 2,\n        containerHeight - minPadding.top * 2,\n      );\n      imagePos.current = {\n        x: (containerWidth - width) * 0.5,\n        y: (containerHeight - height) * 0.5,\n      };\n      setClientSize({\n        scale,\n        width: naturalSize.width * scale,\n        height: naturalSize.height * scale,\n      });\n      lastScalePosRef.current = undefined;\n    }\n  };\n\n  /** Initial position to fit container */\n  useEffect(() => {\n    initClientSizeToFit(naturalSize);\n  }, [naturalSize, containerSize]);\n\n  const adaptImagePosWhileZoom = () => {\n    if (!containerSize) return;\n\n    const containerWidth = containerSize?.width;\n    const containerHeight = containerSize?.height;\n\n    // Default zoom center\n    let posRatioX = 0.5;\n    let posRatioY = 0.5;\n    let mouseX = containerWidth / 2;\n    let mouseY = containerHeight / 2;\n\n    if (lastScalePosRef.current) {\n      posRatioX = lastScalePosRef.current.posRatioX;\n      posRatioY = lastScalePosRef.current.posRatioY;\n      mouseX = lastScalePosRef.current.mouseX;\n      mouseY = lastScalePosRef.current.mouseY;\n    }\n    const x = mouseX - clientSize.width * posRatioX;\n    const y = mouseY - clientSize.height * posRatioY;\n\n    imagePos.current = { x, y };\n  };\n\n  useEffect(() => {\n    adaptImagePosWhileZoom();\n  }, [clientSize]);\n\n  const zoom = (isZoomIn: boolean, step: number, isZoomBtn?: boolean) => {\n    if (!visible || isRequiring) return;\n    setClientSize((s) => {\n      let scale = isZoomIn\n        ? Math.min(MAX_SCALE, fixedFloatNum(s.scale + step, 2))\n        : Math.max(MIN_SCALE, fixedFloatNum(s.scale - step, 2));\n\n      // update scale center\n      if (\n        !lastScalePosRef.current ||\n        containerMouse.elementX !== lastScalePosRef.current.mouseX ||\n        containerMouse.elementY !== lastScalePosRef.current.mouseY\n      ) {\n        if (!isZoomBtn) {\n          const scalePos = {\n            posRatioX: contentMouse.elementX / clientSize.width,\n            posRatioY: contentMouse.elementY / clientSize.height,\n            mouseX: containerMouse.elementX,\n            mouseY: containerMouse.elementY,\n          };\n          lastScalePosRef.current = scalePos;\n        }\n      }\n\n      s.scale = scale;\n      s.width = naturalSize.width * scale;\n      s.height = naturalSize.height * scale;\n    });\n  };\n\n  const onZoomIn = () => {\n    zoom(true, BUTTON_SCALE_STEP, true);\n  };\n\n  const onZoomOut = () => {\n    zoom(false, BUTTON_SCALE_STEP, true);\n  };\n\n  // Zoom gesture.\n  const onWheelMove: React.WheelEventHandler<HTMLDivElement> = (event) => {\n    if (!visible || isRequiring) return;\n    const wheelDirection = event.deltaY;\n    if (wheelDirection > 0) {\n      zoom(false, WHEEL_SCALE_STEP);\n    } else if (wheelDirection < 0) {\n      zoom(true, WHEEL_SCALE_STEP);\n    }\n  };\n\n  const onReset = () => {\n    lastScalePosRef.current = undefined;\n    initClientSizeToFit(naturalSize);\n  };\n\n  // Reset data when hidden.\n  useEffect(() => {\n    if (!visible) {\n      setNaturalSize({ width: 0, height: 0 });\n      setClientSize({\n        scale: 1,\n        width: 0,\n        height: 0,\n      });\n      imagePos.current = { x: 0, y: 0 };\n      lastScalePosRef.current = undefined;\n    }\n  }, [visible]);\n\n  const [isMousePress, setMousePress] = useState(false);\n\n  useEventListener('mousedown', () => {\n    setMousePress(true);\n    if (!visible || !containerRef.current) return;\n    setMovingImgAnchor({\n      x: contentMouse.elementX,\n      y: contentMouse.elementY,\n    });\n  });\n\n  useEventListener('mousemove', () => {\n    if (!visible) return;\n    if (movingImgAnchor && allowMove && isMousePress) {\n      const offsetX = contentMouse.elementX - movingImgAnchor.x;\n      const offsetY = contentMouse.elementY - movingImgAnchor.y;\n      const { x, y } = imagePos.current;\n      imagePos.current = {\n        x: x + offsetX,\n        y: y + offsetY,\n      };\n    }\n  });\n\n  useEventListener('mouseup', () => {\n    setMousePress(false);\n    if (!visible || !allowMove) return;\n    // Stop moving the image.\n    if (movingImgAnchor) {\n      setMovingImgAnchor(null);\n      return;\n    }\n  });\n\n  useEffect(() => {\n    if (!allowMove) {\n      setMovingImgAnchor(null);\n    } else {\n      setMovingImgAnchor({\n        x: contentMouse.elementX,\n        y: contentMouse.elementY,\n      });\n    }\n  }, [allowMove]);\n\n  const onLoadImg = (e: React.UIEvent<HTMLImageElement, UIEvent>) => {\n    const img = e.target as HTMLImageElement;\n    const naturalSize = { width: img.naturalWidth, height: img.naturalHeight };\n    setNaturalSize(naturalSize);\n    initClientSizeToFit(naturalSize);\n  };\n\n  /** Container render function */\n  const CanvasContainer = ({\n    children,\n    className,\n  }: {\n    children: React.ReactNode;\n    className?: string;\n  }) => {\n    if (!visible) return null;\n    return (\n      <div\n        ref={containerRef}\n        onWheel={onWheelMove}\n        onClick={onClickBg}\n        className={className}\n      >\n        {children}\n        {showReferenceLine && !allowMove && isInCanvas(contentMouse) && (\n          <>\n            {/* leftLine */}\n            <div\n              style={{\n                position: 'fixed',\n                backgroundColor: '#fff',\n                width: containerMouse.elementX - 18,\n                height: 1,\n                left: 0,\n                bottom: 0,\n                transformOrigin: 'bottom left',\n                transform: `translate(${containerMouse.elementPosX}px, -${\n                  window.innerHeight - containerMouse.clientY - 1\n                }px)`,\n              }}\n            />\n            {/* rightLine */}\n            <div\n              style={{\n                position: 'fixed',\n                backgroundColor: '#fff',\n                height: 1,\n                width: containerMouse.elementW - containerMouse.elementX - 18,\n                left: 0,\n                bottom: 0,\n                transformOrigin: 'bottom left',\n                transform: `translate(${containerMouse.clientX + 18}px, -${\n                  window.innerHeight - containerMouse.clientY - 1\n                }px)`,\n              }}\n            />\n            {/* upLine */}\n            <div\n              style={{\n                position: 'fixed',\n                backgroundColor: '#fff',\n                width: 1,\n                height: containerMouse.elementY - 18,\n                left: 0,\n                bottom: 0,\n                transformOrigin: 'bottom left',\n                transform: `translate(${containerMouse.clientX - 1}px, \n                  -${window.innerHeight - containerMouse.clientY + 18}px)`,\n              }}\n            />\n            {/* downLine */}\n            <div\n              style={{\n                position: 'fixed',\n                backgroundColor: '#fff',\n                width: 1,\n                height: containerMouse.elementH - containerMouse.elementY - 18,\n                left: 0,\n                bottom: 0,\n                transform: `translate(${containerMouse.clientX - 1}px)`,\n              }}\n            />\n          </>\n        )}\n        {isCustomCursorActive &&\n          cursorSize > 0 &&\n          isInCanvas(containerMouse) &&\n          isInCanvas(contentMouse) &&\n          !allowMove && (\n            <div\n              style={{\n                position: 'fixed',\n                backgroundColor: 'rgba(255, 255, 255, 0.5)',\n                border: '1px solid rgba(255, 255, 255, 0.7)',\n                width: cursorSize * clientSize.scale,\n                height: cursorSize * clientSize.scale,\n                borderRadius: (cursorSize * clientSize.scale) / 2,\n                left: 0,\n                top: 0,\n                transformOrigin: 'top left',\n                transform: `translate(${\n                  containerMouse.clientX - (cursorSize * clientSize.scale) / 2\n                }px, ${\n                  containerMouse.clientY - (cursorSize * clientSize.scale) / 2\n                }px)`,\n              }}\n            />\n          )}\n      </div>\n    );\n  };\n\n  return {\n    CanvasContainer,\n    scale: clientSize.scale,\n    containerRef,\n    naturalSize,\n    clientSize: {\n      width: clientSize.width,\n      height: clientSize.height,\n    },\n    containerSize,\n    containerMouse: {\n      ...containerMouse,\n      elementW: containerSize?.width || containerMouse.elementW,\n      elementH: containerSize?.height || containerMouse.elementH,\n    },\n    contentMouse,\n    imagePos,\n    isMousePress,\n    onLoadImg,\n    onZoomIn,\n    onZoomOut,\n    onWheelMove,\n    onReset,\n  };\n}\n"],"names":[],"sourceRoot":""}